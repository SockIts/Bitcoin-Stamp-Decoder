<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>STAMP Decoder</title>
  <!-- Replace with a valid URL or local path to sha256.js -->
  <!-- <script type="text/javascript" src="path/to/sha256.js"></script> -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
  <script>
    let example_txs = [
      '9e99825880aa7cac75629ec01de28b419f691503af2c4f51b4c8b939fd37e310', //Classic_PNG
      'c46c4e59f64cdcce78e6680079bf6ae9b4d976f07eba2797c02c4c602807b17e', //Classic_GIF
      '703a8e43fbad456480a6a0820584ded924151278a09e1b832b3e11e2299d1a3a', //Classic_SVG
      'ad891d1235b04110e6d174040de034760d1fa4c0a18437f169a1d1de34091ed3', //Classic_HTML
      '9bfd550831fd3fde30a8d168e458340256b58b1e75ad109785d7ce5beb726946', //Olga_PNG
      'c075e98ae365c809ccd2804c1487a799748399eeb9dd61708c814a5da34c9b78', //Olga_GIF
      '2825437c2d6cf4250eca8b7bbc487107cc0ee4dfcd765a2dcf33ce31c7db2f45', //Olga_webp      
      '27000ab9c75570204adc1b3a5e7820c482d99033fbb3aafb844c3a3ce8b063db', //Olga_SVG
      '8c7c8efe339d10a981ae189c7c20851f1e2f10e0e8e6792a99dbe27e32b6b6a6', //Olga_HTML
      '2cfdc5d737065aa5c5c9febde8a803b1e6ee44e47de0f2788f9dfc4d40f7ed71', //Multisig
      '55f8b7a158f0e4330e7a1db287c3495c1ee6c561262e2e8f490b8ae4c6d9fbe5', //subasset
      '9660860095ba470a9622b41ad7b594cb53dce5ade3c79cd2b226b27619bcd40a'  //Olga_SVG_gZIP
    ];

    let standards = ['stamp'];
    let p2wsh = [];

    // Parse URL hash for parameters (e.g., #decode_tx?tx=...)
    const hash = window.location.hash;
    const queryString = hash.includes('?') ? '?' + hash.split('?')[1] : '';
    const urlParams = new URLSearchParams(queryString);
    let network = urlParams.get('network');
    let tx = urlParams.get('tx');
    if (network === 'testnet') network = 'test3';
    if (network !== 'test3') network = 'main';
    if (tx == 'random') tx = example_txs[Math.floor(Math.random() * example_txs.length)];
    if (!isNaN(tx)) tx = example_txs[parseInt(tx)];

    async function get(tx) {
      try {
        if (!/^[0-9a-fA-F]{64}$/.test(tx)) {
          throw new Error('Invalid transaction ID format');
        }
        let url = `https://api.blockcypher.com/v1/btc/${network}/txs/${tx}?instart=0&outstart=0&limit=5000`;
        let response = await fetch(url, { method: 'GET', mode: 'cors' });
        if (!response.ok) {
          let errorText = await response.text().catch(() => 'Unknown error');
          throw new Error(`HTTP ${response.status}: ${errorText}`);
        }
        let obj = await response.json();
        if (!obj || !obj.hash) {
          throw new Error('Invalid or empty transaction data');
        }
        while (obj.next_outputs) {
          let nextResponse = await fetch(obj.next_outputs, { method: 'GET', mode: 'cors' });
          if (!nextResponse.ok) {
            throw new Error(`HTTP ${nextResponse.status}: Failed to fetch additional outputs`);
          }
          let nextObj = await nextResponse.json();
          obj.outputs = obj.outputs.concat(nextObj.outputs);
          obj.next_outputs = nextObj.next_outputs;
        }
        console.log(`Fetched ${obj.outputs.length} outputs for tx ${tx}`);
        return obj;
      } catch (e) {
        console.error('Error fetching transaction:', e.message, { tx, network, url });
        return null;
      }
    }

    async function getRawTx(tx) {
      console.log('Fetching raw transaction data for witness scripts...');
      return null; // Placeholder
    }

    function getImageDimensions(base64, file_type) {
      return new Promise((resolve) => {
        try {
          if (!/^[a-zA-Z0-9+\/=]+$/.test(base64)) {
            throw new Error('Invalid base64 string');
          }
          if (file_type === 'svg+xml') {
            let xml = atob(base64);
            let parser = new DOMParser();
            let svgDoc = parser.parseFromString(xml, 'image/svg+xml');
            let svgElement = svgDoc.querySelector('svg');
            if (svgElement) {
              let width = svgElement.getAttribute('width') || 'unknown';
              let height = svgElement.getAttribute('height') || 'unknown';
              if (width && height && !isNaN(parseFloat(width)) && !isNaN(parseFloat(height))) {
                resolve(`${parseFloat(width)}x${parseFloat(height)}`);
              } else {
                resolve('unknown');
              }
            } else {
              resolve('unknown');
            }
          } else if (file_type === 'html') {
            resolve('300x300');
          } else {
            let img = new Image();
            img.onload = function() {
              resolve(`${img.width}x${img.height}`);
            };
            img.onerror = function() {
              resolve('unknown');
            };
            img.src = `data:image/${file_type};base64,${base64}`;
          }
        } catch (e) {
          console.error('Error getting dimensions:', e);
          resolve('unknown');
        }
      });
    }

    async function get_json(tx) {
      if (typeof tx !== 'undefined' && /^[0-9a-fA-F]{64}$/.test(tx)) {
        (async () => {
          let json = await get(tx);
          if (!json) {
            document.getElementById("output").innerHTML = wl('Error', `Failed to fetch transaction data for ${tx}`);
            return;
          }
          let rawHex = await getRawTx(tx);
          decode(json, rawHex, tx);
          const notification = document.createElement('div');
          notification.style.cssText = 'position: fixed; top: 20px; right: 20px; background-color: #28a745; color: white; padding: 10px 20px; border-radius: 5px; z-index: 1000;';
          notification.textContent = 'Done! LFG';
          document.body.appendChild(notification);
          setTimeout(() => {
            notification.remove();
          }, 3000);
        })();
      } else {
        document.getElementById("output").innerHTML = wl('Error', 'Invalid transaction ID');
      }
    }

    async function decode(json, rawHex, tx) {
      try {
        json = JSON.parse(JSON.stringify(json));
        let hash = json['hash'];
        let block_height = json['block_height'] || 'unknown';
        let block_time = json['received'] ? new Date(json['received']).toLocaleString() : 'unknown';
        let from_addr = json['addresses'] && json['addresses'][0] ? json['addresses'][0] : 'unknown';
        let utxo = json['inputs'] && json['inputs'][0]['prev_hash'] ? json['inputs'][0]['prev_hash'] : 'unknown';
        let first_send_sat = json['outputs'] && json['outputs'][0]['value'] ? json['outputs'][0]['value'] : 0;
        let script_type = [];
        let script = [];
        let to_addr = [];
        p2wsh = [];

        for (const x of json['outputs'] || []) {
          let type = x['script_type'];
          script_type.push(type);
          if (type == 'pay-to-pubkey-hash') {
            script.push('0');
            to_addr.push(x['addresses'] && x['addresses'][0] ? x['addresses'][0] : 'unknown');
          } else if (type == 'pay-to-multi-pubkey-hash') {
            script.push(x['script']);
            to_addr.push('0');
          } else if (type == 'null-data') {
            script.push(x['data_hex']);
            to_addr.push('0');
          } else if (type == 'pay-to-witness-script-hash') {
            script.push(x['script']);
            p2wsh.push([x['script'], x['value']]);
          } else {
            script.push('?');
            to_addr.push('?');
          }
        }

        let recipient = script_type[0] == 'pay-to-pubkey-hash' ? to_addr[0] : '0';
        let cp_msg = '';
        let encoding = '';
        let out = '';

        for (let i = 0; i < script.length; i++) {
          if (script_type[i] == 'null-data') {
            encoding = 'op_return';
            let raw = script[i];
            raw = xcp_rc4(utxo, raw);
            if (raw.substring(0, 16) == '434e545250525459') {
              cp_msg += raw;
            } else {
              out += wl('Error', 'Invalid RC4 decryption for OP_RETURN: ' + raw.substring(0, 16));
            }
          }
          if (script_type[i] == 'pay-to-multi-pubkey-hash') {
            let raw = script[i];
            let len = 0;
            if (raw.length == 142) {
              encoding = 'op_return';
              let len_hex = raw.substring(72, 74);
              len = parseInt(hexToDec(len_hex));
              if (isNaN(len) || len < 0 || len > (raw.length - 74) / 2) {
                console.error(`Invalid length in multisig script ${i}: len=${len}, script=${raw}`);
                continue;
              }
              raw = raw.substring(74, 74 + (len * 2));
              if (!/^[0-9a-fA-F]+$/.test(raw)) {
                console.error(`Invalid hex data in multisig script ${i}: ${raw}`);
                continue;
              }
              console.log(`Multisig output ${i} (length ${script[i].length}): len=${len}, raw=${raw}`);
              cp_msg += raw;
            } else if (raw.length == 210) {
              encoding = 'multisig';
              raw = raw.substring(6, 68) + raw.substring(74, 136);
              raw = xcp_rc4(utxo, raw);
              len = parseInt(hexToDec(raw.substring(0, 2)));
              if (isNaN(len) || len < 0 || len > (raw.length - 2) / 2) {
                console.error(`Invalid length in multisig script ${i}: len=${len}, script=${raw}`);
                continue;
              }
              raw = raw.substring(2, 2 + (len * 2));
              if (!/^[0-9a-fA-F]+$/.test(raw)) {
                console.error(`Invalid hex data in multisig script ${i}: ${raw}`);
                continue;
              }
              console.log(`Multisig output ${i} (length ${script[i].length}): len=${len}, raw=${raw}`);
              if (cp_msg == '') {
                cp_msg += raw;
              } else {
                if (raw.substring(0, 16) == '434e545250525459') {
                  raw = raw.substring(16);
                }
                cp_msg += raw;
              }
            } else {
              encoding = 'multisig (custom length)';
              raw = xcp_rc4(utxo, raw);
              len = parseInt(hexToDec(raw.substring(0, 2)));
              if (isNaN(len) || len < 0 || len > (raw.length - 2) / 2) {
                console.error(`Invalid length in multisig script ${i}: len=${len}, script=${raw}`);
                continue;
              }
              raw = raw.substring(2, 2 + (len * 2));
              if (!/^[0-9a-fA-F]+$/.test(raw)) {
                console.error(`Invalid hex data in multisig script ${i}: ${raw}`);
                continue;
              }
              console.log(`Multisig output ${i} (length ${script[i].length}): len=${len}, raw=${raw}`);
              if (cp_msg == '') {
                cp_msg += raw;
              } else {
                if (raw.substring(0, 16) == '434e545250525459') {
                  raw = raw.substring(16);
                }
                cp_msg += raw;
              }
            }
          }
        }
        console.log(`Final cp_msg: ${cp_msg}`);

        out += '<div class="section-title">BITCOIN DATA</div>';
        out += wl('Tx ID', hash);
        out += wl('Block #', block_height);
        out += wl('Block Time', block_time);
        out += wl('Address', from_addr);
        out += '<div class="section-title">COUNTERPARTY DATA</div>';

        out += `<div class="output-row"><span class="output-label">Raw (hex)</span><span class="output-value"><details><summary>Hex: (click to expand/collapse)</summary><pre class="base64-content">${chunk(cp_msg, 96)}</pre></details></span></div>`;
        out += `<div class="output-row"><span class="output-label">Raw (ascii)</span><span class="output-value"><details><summary>ASCII: (click to expand/collapse)</summary><pre class="base64-content">${chunk(hex2a(cp_msg), 96)}</pre></details></span></div>`;

        if (cp_msg.substring(0, 16) != '434e545250525459') {
          out += wl('Error', 'No valid Counterparty data found');
          if (p2wsh.length > 0) {
            console.log('P2WSH outputs found; attempting OLGA STAMP decoding');
            out += await print_standard('stamp:', tx, 'A' + BigInt('0x' + cp_msg.substring(2, 18)).toString(10), cp_msg);
          } else {
            out += wl('Error', 'No valid Counterparty data or P2WSH outputs found');
          }
          document.getElementById("output").innerHTML = out;
          output2(hash);
          return;
        }

        cp_msg = cp_msg.substring(16);
        console.log(`After removing CNTRPRTY: cp_msg=${cp_msg}`);
        if (cp_msg.length < 36) {
          out += wl('Error', `Invalid Counterparty message length: ${cp_msg.length} (expected at least 36)`);
          document.getElementById("output").innerHTML = out;
          output2(hash);
          return;
        }

        let id_hex = cp_msg.substring(0, 2);
        let id = parseInt(id_hex, 16);
        console.log(`id_hex=${id_hex}, id=${id}`);
        cp_msg = cp_msg.substring(2);

        out += wl('Message ID (hex)', id_hex);
        out += wl('Message ID', id);

        // Ensure block_height is a number for comparison
        let blockHeightNum = block_height === 'unknown' ? 0 : parseInt(block_height);

        // Rule-based decoding
        if (id == 20 && blockHeightNum < 753500) {
          // Rule 1: Classic Stamp
          out += wl('Type', 'Issuance (Classic Stamp)');
          let asset_hex = cp_msg.substring(0, 16);
          let asset = BigInt('0x' + asset_hex).toString(10);
          cp_msg = cp_msg.substring(16);

          let q_hex = cp_msg.substring(0, 16);
          if (!/^[0-9a-fA-F]{16}$/.test(q_hex)) {
            console.error(`Invalid q_hex format: ${q_hex}`);
            out += wl('Error', `Invalid issuance quantity format: ${q_hex}`);
            document.getElementById("output").innerHTML = out;
            output2(hash);
            return;
          }
          let q = Number(BigInt('0x' + q_hex));
          cp_msg = cp_msg.substring(16);

          let div_hex = cp_msg.substring(0, 2);
          let div = parseInt(div_hex, 16) ? true : false;
          cp_msg = cp_msg.substring(2);

          let lock_hex = cp_msg.substring(0, 2);
          let lock = parseInt(lock_hex, 16) ? true : false;
          cp_msg = cp_msg.substring(2);

          let reset_hex = cp_msg.substring(0, 2);
          let reset = parseInt(reset_hex, 16) ? true : false;
          cp_msg = cp_msg.substring(2);

          out += wl('Asset', 'A' + asset);
          out += wl('Issuance', q);
          out += wl('Divisible', div);
          out += wl('Lock', lock);
          out += wl('Reset', reset);

          let descr_hex = cp_msg;
          let descr = hex2a(descr_hex);
          if (descr.toLowerCase().startsWith('stamp:')) {
            out += await print_standard('stamp:', tx, 'A' + asset, descr);
          } else {
            out += wl('Error', 'Expected Classic Stamp description starting with "stamp:"');
          }

        } else if (id == 21 && blockHeightNum < 753500) {
          // Rule 2: Subasset (Classic)
          out += wl('Type', 'Issuance (Subasset Classic)');
          let asset_hex = cp_msg.substring(0, 16);
          let asset = BigInt('0x' + asset_hex).toString(10);
          cp_msg = cp_msg.substring(16);

          let q_hex = cp_msg.substring(0, 16);
          if (!/^[0-9a-fA-F]{16}$/.test(q_hex)) {
            console.error(`Invalid q_hex format: ${q_hex}`);
            out += wl('Error', `Invalid issuance quantity format: ${q_hex}`);
            document.getElementById("output").innerHTML = out;
            output2(hash);
            return;
          }
          let q = Number(BigInt('0x' + q_hex));
          cp_msg = cp_msg.substring(16);

          let div_hex = cp_msg.substring(0, 2);
          let div = parseInt(div_hex, 16) ? true : false;
          cp_msg = cp_msg.substring(2);

          let lock_hex = cp_msg.substring(0, 2);
          let lock = parseInt(lock_hex, 16) ? true : false;
          cp_msg = cp_msg.substring(2);

          let reset_hex = cp_msg.substring(0, 2);
          let reset = parseInt(reset_hex, 16) ? true : false;
          cp_msg = cp_msg.substring(2);

          let len_subasset_hex = cp_msg.substring(0, 2);
          let len_subasset = parseInt(len_subasset_hex, 16);
          cp_msg = cp_msg.substring(2);
          if (cp_msg.length < len_subasset * 2) {
            out += wl('Error', `Invalid subasset length: ${len_subasset}, remaining cp_msg length: ${cp_msg.length}`);
            document.getElementById("output").innerHTML = out;
            output2(hash);
            return;
          }
          let subasset_hex = cp_msg.substring(0, len_subasset * 2);
          let subasset = hex_to_subasset(subasset_hex);
          cp_msg = cp_msg.substring(len_subasset * 2);

          let descr_hex = cp_msg;
          let descr = hex2a(descr_hex);

          out += wl('Asset', 'A' + asset);
          out += wl('Subasset', subasset);
          out += wl('Subasset (hex)', subasset_hex);
          out += wl('Issuance', q);
          out += wl('Divisible', div);
          out += wl('Lock', lock);
          out += wl('Reset', reset);

          if (descr.toLowerCase().startsWith('stamp:')) {
            out += await print_standard('stamp:', tx, 'A' + asset, descr);
          } else {
            out += wl('Description', descr);
            out += wl('Description (hex)', descr_hex);
          }

        } else if (id == 20 && blockHeightNum >= 753500) {
          // Rule 3: Olga Stamp
          out += wl('Type', 'Issuance (Olga Stamp)');
          let asset_hex = cp_msg.substring(0, 16);
          let asset = BigInt('0x' + asset_hex).toString(10);
          cp_msg = cp_msg.substring(16);

          let q_hex = cp_msg.substring(0, 16);
          if (!/^[0-9a-fA-F]{16}$/.test(q_hex)) {
            console.error(`Invalid q_hex format: ${q_hex}`);
            out += wl('Error', `Invalid issuance quantity format: ${q_hex}`);
            document.getElementById("output").innerHTML = out;
            output2(hash);
            return;
          }
          let q = Number(BigInt('0x' + q_hex));
          cp_msg = cp_msg.substring(16);

          let div_hex = cp_msg.substring(0, 2);
          let div = parseInt(div_hex, 16) ? true : false;
          cp_msg = cp_msg.substring(2);

          let lock_hex = cp_msg.substring(0, 2);
          let lock = parseInt(lock_hex, 16) ? true : false;
          cp_msg = cp_msg.substring(2);

          let reset_hex = cp_msg.substring(0, 2);
          let reset = parseInt(reset_hex, 16) ? true : false;
          cp_msg = cp_msg.substring(2);

          out += wl('Asset', 'A' + asset);
          out += wl('Issuance', q);
          out += wl('Divisible', div);
          out += wl('Lock', lock);
          out += wl('Reset', reset);

          out += await print_standard('stamp:', tx, 'A' + asset, p2wsh.length > 0 ? '' : cp_msg);

        } else if (id == 22 && blockHeightNum >= 819300) {
          // Rule 4: Olga Stamp
          out += wl('Type', 'Issuance (Olga Stamp)');
          let asset_hex = cp_msg.substring(0, 16);
          let asset = BigInt('0x' + asset_hex).toString(10);
          cp_msg = cp_msg.substring(16);

          let q_hex = cp_msg.substring(0, 16);
          if (!/^[0-9a-fA-F]{16}$/.test(q_hex)) {
            console.error(`Invalid q_hex format: ${q_hex}`);
            out += wl('Error', `Invalid issuance quantity format: ${q_hex}`);
            document.getElementById("output").innerHTML = out;
            output2(hash);
            return;
          }
          let q = Number(BigInt('0x' + q_hex));
          cp_msg = cp_msg.substring(16);

          let div_hex = cp_msg.substring(0, 2);
          let div = parseInt(div_hex, 16) ? true : false;
          cp_msg = cp_msg.substring(2);

          let lock_hex = cp_msg.substring(0, 2);
          let lock = parseInt(lock_hex, 16) ? true : false;
          cp_msg = cp_msg.substring(2);

          let reset_hex = cp_msg.substring(0, 2);
          let reset = parseInt(reset_hex, 16) ? true : false;
          cp_msg = cp_msg.substring(2);

          out += wl('Asset', 'A' + asset);
          out += wl('Issuance', q);
          out += wl('Divisible', div);
          out += wl('Lock', lock);
          out += wl('Reset', reset);

          out += await print_standard('stamp:', tx, 'A' + asset, p2wsh.length > 0 ? '' : cp_msg);

        } else if (id == 21 && blockHeightNum >= 753500) {
          // Rule 5: Subasset (Olga)
          out += wl('Type', 'Issuance (Subasset Olga)');
          let asset_hex = cp_msg.substring(0, 16);
          let asset = BigInt('0x' + asset_hex).toString(10);
          cp_msg = cp_msg.substring(16);

          let q_hex = cp_msg.substring(0, 16);
          if (!/^[0-9a-fA-F]{16}$/.test(q_hex)) {
            console.error(`Invalid q_hex format: ${q_hex}`);
            out += wl('Error', `Invalid issuance quantity format: ${q_hex}`);
            document.getElementById("output").innerHTML = out;
            output2(hash);
            return;
          }
          let q = Number(BigInt('0x' + q_hex));
          cp_msg = cp_msg.substring(16);

          let div_hex = cp_msg.substring(0, 2);
          let div = parseInt(div_hex, 16) ? true : false;
          cp_msg = cp_msg.substring(2);

          let lock_hex = cp_msg.substring(0, 2);
          let lock = parseInt(lock_hex, 16) ? true : false;
          cp_msg = cp_msg.substring(2);

          let reset_hex = cp_msg.substring(0, 2);
          let reset = parseInt(reset_hex, 16) ? true : false;
          cp_msg = cp_msg.substring(2);

          let len_subasset_hex = cp_msg.substring(0, 2);
          let len_subasset = parseInt(len_subasset_hex, 16);
          cp_msg = cp_msg.substring(2);
          if (cp_msg.length < len_subasset * 2) {
            out += wl('Error', `Invalid subasset length: ${len_subasset}, remaining cp_msg length: ${cp_msg.length}`);
            document.getElementById("output").innerHTML = out;
            output2(hash);
            return;
          }
          let subasset_hex = cp_msg.substring(0, len_subasset * 2);
          let subasset = hex_to_subasset(subasset_hex);
          cp_msg = cp_msg.substring(len_subasset * 2);

          let descr_hex = cp_msg;
          let descr = hex2a(descr_hex);

          out += wl('Asset', 'A' + asset);
          out += wl('Subasset', subasset);
          out += wl('Subasset (hex)', subasset_hex);
          out += wl('Issuance', q);
          out += wl('Divisible', div);
          out += wl('Lock', lock);
          out += wl('Reset', reset);

          if (descr.toLowerCase().startsWith('stamp:')) {
            out += await print_standard('stamp:', tx, 'A' + asset, descr);
          } else {
            out += wl('Description', descr);
            out += wl('Description (hex)', descr_hex);
          }

        } else if (id == 23 && blockHeightNum >= 819300) {
          // Rule 6: Subasset (Olga)
          out += wl('Type', 'Issuance (Subasset Olga)');
          let asset_hex = cp_msg.substring(0, 16);
          let asset = BigInt('0x' + asset_hex).toString(10);
          cp_msg = cp_msg.substring(16);

          let q_hex = cp_msg.substring(0, 16);
          if (!/^[0-9a-fA-F]{16}$/.test(q_hex)) {
            console.error(`Invalid q_hex format: ${q_hex}`);
            out += wl('Error', `Invalid issuance quantity format: ${q_hex}`);
            document.getElementById("output").innerHTML = out;
            output2(hash);
            return;
          }
          let q = Number(BigInt('0x' + q_hex));
          cp_msg = cp_msg.substring(16);

          let div_hex = cp_msg.substring(0, 2);
          let div = parseInt(div_hex, 16) ? true : false;
          cp_msg = cp_msg.substring(2);

          let lock_hex = cp_msg.substring(0, 2);
          let lock = parseInt(lock_hex, 16) ? true : false;
          cp_msg = cp_msg.substring(2);

          let reset_hex = cp_msg.substring(0, 2);
          let reset = parseInt(reset_hex, 16) ? true : false;
          cp_msg = cp_msg.substring(2);

          let len_subasset_hex = cp_msg.substring(0, 2);
          let len_subasset = parseInt(len_subasset_hex, 16);
          cp_msg = cp_msg.substring(2);
          if (cp_msg.length < len_subasset * 2) {
            out += wl('Error', `Invalid subasset length: ${len_subasset}, remaining cp_msg length: ${cp_msg.length}`);
            document.getElementById("output").innerHTML = out;
            output2(hash);
            return;
          }
          let subasset_hex = cp_msg.substring(0, len_subasset * 2);
          let subasset = hex_to_subasset(subasset_hex);
          cp_msg = cp_msg.substring(len_subasset * 2);

          let descr_hex = cp_msg;
          let descr = hex2a(descr_hex);

          out += wl('Asset', 'A' + asset);
          out += wl('Subasset', subasset);
          out += wl('Subasset (hex)', subasset_hex);
          out += wl('Issuance', q);
          out += wl('Divisible', div);
          out += wl('Lock', lock);
          out += wl('Reset', reset);

          if (descr.toLowerCase().startsWith('stamp:')) {
            out += await print_standard('stamp:', tx, 'A' + asset, descr);
          } else {
            out += wl('Description', descr);
            out += wl('Description (hex)', descr_hex);
          }

        } else {
          out += wl('Error', 'Not a valid Issuance or Subasset transaction! Message ID: ' + id + ', Block Height: ' + block_height);
        }

        if (recipient != '0') {
          out += wl('Transfer To', recipient);
          out += wl('Dust (sat)', first_send_sat);
          out += wl('Dust (btc)', (first_send_sat / 100000000).toFixed(8));
        }

        document.getElementById("output").innerHTML = out;
        output2(hash);
      } catch (e) {
        console.error('Error in decode:', e);
        document.getElementById("output").innerHTML = wl('Error', 'Failed to decode transaction: ' + e.message);
      }
    }

    function output2(tx) {
      let out = '<br>';
      out += 'View on: <br>';
      out += '<a href="https://stampchain.io/api/v2/stamps/' + tx + '">Stampchain.io</a> ';
      out += '<a href="https://live.blockcypher.com/btc/tx/' + tx + '/">BlockCypher</a> ';
      out += '<a href="https://www.blockchain.com/btc/tx/' + tx + '">Blockchain.com</a> ';
      out += '<a href="https://blockstream.info/tx/' + tx + '">Blockstream</a>';
      document.getElementById("output2").innerHTML = out;
    }

    function wl(title, info) {
      return `<div class="output-row"><span class="output-label">${title}</span><span class="output-value">${chunk(String(info), '<br>', 96)}</span></div>`;
    }

    function chunk(str, sep, n) {
      str = String(str);
      var ret = [];
      for (var i = 0, len = str.length; i < len; i += n) {
        ret.push(str.substr(i, n));
      }
      return ret.join(sep);
    }

    function hex2a(hexx) {
      if (!/^[0-9a-fA-F]+$/.test(hexx)) {
        console.error(`Invalid hex in hex2a: ${hexx.slice(0, 50)}...`);
        return '';
      }
      var hex = hexx.toString();
      var str = '';
      for (var i = 0; i < hex.length; i += 2) {
        str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
      }
      return str;
    }

    function xcp_rc4(key, datachunk) {
      return bin2hex(rc4(hex2bin(key), hex2bin(datachunk)));
    }

    function hex2bin(hex) {
      var bytes = [];
      for (var i = 0; i < hex.length - 1; i += 2) {
        var ch = parseInt(hex.substr(i, 2), 16);
        bytes.push(ch);
      }
      return String.fromCharCode.apply(String, bytes);
    }

    function bin2hex(s) {
      var o = '';
      for (var i = 0, l = s.length; i < l; i++) {
        var n = s.charCodeAt(i).toString(16);
        o += n.length < 2 ? '0' + n : n;
      }
      return o;
    }

    function rc4(key, str) {
      var s = [], j = 0, x, res = '';
      for (var i = 0; i < 256; i++) {
        s[i] = i;
      }
      for (i = 0; i < 256; i++) {
        j = (j + s[i] + key.charCodeAt(i % key.length)) % 256;
        x = s[i];
        s[i] = s[j];
        s[j] = x;
      }
      i = 0;
      j = 0;
      for (var y = 0; y < str.length; y++) {
        i = (i + 1) % 256;
        j = (j + s[i]) % 256;
        x = s[i];
        s[i] = s[j];
        s[j] = x;
        res += String.fromCharCode(str.charCodeAt(y) ^ s[(s[i] + s[j]) % 256]);
      }
      return res;
    }

    function hexToDec(s) {
      var digits = [0], carry;
      for (var i = 0; i < s.length; i += 1) {
        carry = parseInt(s.charAt(i), 16);
        for (var j = 0; j < digits.length; j += 1) {
          digits[j] = digits[j] * 16 + carry;
          carry = digits[j] / 10 | 0;
          digits[j] %= 10;
        }
        while (carry > 0) {
          digits.push(carry % 10);
          carry = carry / 10 | 0;
        }
      }
      return digits.reverse().join('');
    }

    function asset_name(id) {
      if (id == 0) return 'BTC';
      if (id == 1) return 'XCP';
      if (id >= 95428956661682177) return 'numerical or sub-asset';
      if (id > 9007199254740991) return 'max int error';
      let b26_digits = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      let n = id;
      let name = '';
      do {
        let mod = n % 26;
        name = b26_digits[mod] + name;
        n -= mod;
        n /= 26;
      } while (n > 0);
      return name;
    }

    function hex_to_subasset(hex) {
      const SUBASSET_DIGITS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-_@!';
      let integer = BigInt('0x' + hex);
      let ret = '';
      while (integer != 0n) {
        ret = SUBASSET_DIGITS[(integer % 68n) - 1n] + ret;
        integer = integer / 68n;
      }
      return ret;
    }

    async function print_standard(descr, tx, assetOrCPID, cp_msg) {
      let out = '';
      if (descr.toLowerCase().startsWith('stamp:')) {
        if (/^[a-zA-Z0-9+\/=]+$/.test(descr.substr(6))) {
          out += wl('Standard', 'STAMP (Classic)');
          let image = descr.slice(6).replace(/\s/g, ''); // Remove whitespace
          let paddingNeeded = (4 - (image.length % 4)) % 4;
          image += '='.repeat(paddingNeeded); // Ensure proper padding
          console.log(`Classic stamp base64 (cleaned): ${image.slice(0, 50)}...`);
          if (/^[a-zA-Z0-9+\/=]+$/.test(image) && image.length % 4 === 0) {
            let file_type = '';
            let isGzip = image.startsWith('H4sI');
            let processedImage = image;
            try {
              if (isGzip) {
                console.log('Detected gZIP-compressed Base64 in Classic stamp');
                let decoded;
                try {
                  decoded = atob(image);
                  console.log(`Base64 decoded: ${decoded.slice(0, 50)}...`);
                } catch (e) {
                  out += wl('Error', 'Failed to decode base64 for Classic STAMP: ' + e.message);
                  console.error(`Base64 decode error in Classic stamp: ${e.message}, image=${image.slice(0, 50)}...`);
                  return out;
                }
                try {
                  // Convert decoded string to Uint8Array for pako
                  let binary = new Uint8Array(decoded.length);
                  for (let i = 0; i < decoded.length; i++) {
                    binary[i] = decoded.charCodeAt(i);
                  }
                  let decompressed = pako.ungzip(binary, { to: 'string' });
                  processedImage = btoa(decompressed);
                  console.log(`Decompressed gZIP base64: ${processedImage.slice(0, 50)}...`);
                } catch (e) {
                  out += wl('Error', 'Failed to decompress gZIP data for Classic STAMP: ' + e.message);
                  console.error(`gZIP decompression error in Classic stamp: ${e.message}, image=${image.slice(0, 50)}...`);
                  return out;
                }
              }
              let decoded;
              try {
                decoded = atob(processedImage);
                console.log(`Decoded Classic stamp starts with: ${decoded.slice(0, 50)}...`);
              } catch (e) {
                out += wl('Error', 'Invalid base64 data for Classic STAMP: ' + e.message);
                console.error(`Base64 decode error in Classic stamp: ${e.message}, image=${image.slice(0, 50)}...`);
                return out;
              }
              if (processedImage.slice(0, 6) === 'R0lGOD') {
                file_type = 'gif';
                console.log('Detected GIF in Classic stamp');
              } else if (processedImage.slice(0, 6) === 'iVBORw') {
                file_type = 'png';
                console.log('Detected PNG in Classic stamp');
              } else if (processedImage.slice(0, 4) === '/9j/') {
                file_type = 'jpeg';
                console.log('Detected JPEG in Classic stamp');
              } else if (processedImage.slice(0, 5) === 'PHN2Z' || processedImage.slice(0, 5) === 'PD94b') {
                file_type = 'svg+xml';
                console.log('Detected SVG in Classic stamp');
              } else if (processedImage.slice(0, 5) === 'UklGR') {
                file_type = 'webp';
                console.log('Detected WebP in Classic stamp');
              } else {
                file_type = 'html';
                console.log('Detected HTML in Classic stamp (default)');
              }
              
              out += wl('Compression', isGzip ? 'gZIP' : 'None');
              out += wl('MIME Type', file_type === 'html' ? 'text/html' : `image/${file_type}`);
              out += `<div class="output-row"><span class="output-label">Description</span><span class="output-value"><details><summary>Base64: (click to expand/collapse)</summary><pre class="base64-content">STAMP:${image}</pre></details></span></div>`;
              out += `<div class="output-row"><span class="output-label">Description (hex)</span><span class="output-value"><details><summary>Hex: (click to expand/collapse)</summary><pre class="base64-content">${chunk(bin2hex('STAMP:' + image), 96)}</pre></details></span></div>`;
              let dimensions = await getImageDimensions(processedImage, file_type);
              out += wl('Dimensions', dimensions);
              
              if (file_type === 'html') {
                out += `<iframe class="stamp-iframe" src="data:text/html;base64,${processedImage}"></iframe><br>`;
              } else {
                out += `<img class="stamp-image" src="data:image/${file_type};base64,${processedImage}" /><br>`;
              }
            } catch (e) {
              out += wl('Error', 'Invalid base64 data for Classic STAMP: ' + e.message);
              console.error(`Base64 decode error in Classic stamp: ${e.message}, image=${image.slice(0, 50)}...`);
            }
          } else {
            out += wl('Error', 'Invalid base64 format for Classic STAMP');
            console.error(`Invalid base64 format: ${image.slice(0, 50)}...`);
          }
        } else {
          out += wl('Standard', 'STAMP (OLGA)');
          let hex = '';
          let dust = 0;
          if (p2wsh.length === 0) {
            console.log(`No P2WSH outputs; using multisig data for OLGA STAMP: cp_msg=${cp_msg}`);
            if (!cp_msg || cp_msg.length <= 4) {
              out += wl('Error', 'No valid multisig data for OLGA STAMP');
              console.error(`Invalid or missing cp_msg: ${cp_msg}`);
              return out;
            }
            console.log(`Processing multisig data: cp_msg=${cp_msg}`);
            hex = cp_msg;
            if (!/^[0-9a-fA-F]+$/.test(hex)) {
              out += wl('Error', 'Invalid hex format in multisig data for OLGA STAMP');
              console.error(`Invalid hex: ${hex}`);
              return out;
            }
            let file_size_hex = hex.slice(0, 4);
            let file_size = parseInt(file_size_hex, 16);
            console.log(`File size hex=${file_size_hex}, file_size=${file_size}, hex length=${hex.length}`);
            if (isNaN(file_size) || file_size <= 0 || hex.length < file_size * 2 + 4) {
              let descr = hex2a(hex);
              descr = decodeURIComponent(escape(descr));
              console.log(`Invalid file size, attempting Classic stamp parsing: descr=${descr}`);
              if (descr.toLowerCase().startsWith('stamp:')) {
                out += wl('Standard', 'STAMP (Classic)');
                let image = descr.slice(6).replace(/\s/g, ''); // Remove whitespace
                let paddingNeeded = (4 - (image.length % 4)) % 4;
                image += '='.repeat(paddingNeeded); // Ensure proper padding
                console.log(`Classic stamp base64 (cleaned): ${image.slice(0, 50)}...`);
                if (/^[a-zA-Z0-9+\/=]+$/.test(image) && image.length % 4 === 0) {
                  let file_type = '';
                  let isGzip = image.startsWith('H4sI');
                  let processedImage = image;
                  try {
                    if (isGzip) {
                      console.log('Detected gZIP-compressed Base64 in Classic fallback');
                      let decoded;
                      try {
                        decoded = atob(image);
                      } catch (e) {
                        out += wl('Error', 'Failed to decode base64 for Classic STAMP: ' + e.message);
                        console.error(`Base64 decode error in Classic stamp: ${e.message}, image=${image.slice(0, 50)}...`);
                        return out;
                      }
                      try {
                        // Convert decoded string to Uint8Array for pako
                        let binary = new Uint8Array(decoded.length);
                        for (let i = 0; i < decoded.length; i++) {
                          binary[i] = decoded.charCodeAt(i);
                        }
                        let decompressed = pako.ungzip(binary, { to: 'string' });
                        processedImage = btoa(decompressed);
                        console.log(`Decompressed gZIP base64: ${processedImage.slice(0, 50)}...`);
                      } catch (e) {
                        out += wl('Error', 'Failed to decompress gZIP data for Classic STAMP: ' + e.message);
                        console.error(`gZIP decompression error in Classic stamp: ${e.message}, image=${image.slice(0, 50)}...`);
                        return out;
                      }
                    }
                    let decoded;
                    try {
                      decoded = atob(processedImage);
                      console.log(`Decoded Classic stamp starts with: ${decoded.slice(0, 50)}...`);
                    } catch (e) {
                      out += wl('Error', 'Invalid base64 data for Classic STAMP: ' + e.message);
                      console.error(`Base64 decode error in Classic stamp: ${e.message}, image=${image.slice(0, 50)}...`);
                      return out;
                    }
                    if (processedImage.slice(0, 6) === 'R0lGOD') {
                      file_type = 'gif';
                      console.log('Detected GIF in Classic stamp');
                    } else if (processedImage.slice(0, 6) === 'iVBORw') {
                      file_type = 'png';
                      console.log('Detected PNG in Classic stamp');
                    } else if (processedImage.slice(0, 4) === '/9j/') {
                      file_type = 'jpeg';
                      console.log('Detected JPEG in Classic stamp');
                    } else if (processedImage.slice(0, 5) === 'PHN2Z' || processedImage.slice(0, 5) === 'PD94b') {
                      file_type = 'svg+xml';
                      console.log('Detected SVG in Classic stamp');
                    } else if (processedImage.slice(0, 5) === 'UklGR') {
                      file_type = 'webp';
                      console.log('Detected WebP in Classic stamp');
                    } else {
                      file_type = 'html';
                      console.log('Detected HTML in Classic stamp (default)');
                    }
                    
                    out += wl('Compression', isGzip ? 'gZIP' : 'None');
                    out += wl('MIME Type', file_type === 'html' ? 'text/html' : `image/${file_type}`);
                    out += `<div class="output-row"><span class="output-label">Description</span><span class="output-value"><details><summary>Base64: (click to expand/collapse)</summary><pre class="base64-content">STAMP:${image}</pre></details></span></div>`;
                    out += `<div class="output-row"><span class="output-label">Description (hex)</span><span class="output-value"><details><summary>Hex: (click to expand/collapse)</summary><pre class="base64-content">${chunk(bin2hex('STAMP:' + image), 96)}</pre></details></span></div>`;
                    let dimensions = await getImageDimensions(processedImage, file_type);
                    out += wl('Dimensions', dimensions);
                    
                    if (file_type === 'html') {
                      out += `<iframe class="stamp-iframe" src="data:text/html;base64,${processedImage}"></iframe><br>`;
                    } else {
                      out += `<img class="stamp-image" src="data:image/${file_type};base64,${processedImage}" /><br>`;
                    }
                  } catch (e) {
                    out += wl('Error', 'Invalid base64 data for Classic STAMP: ' + e.message);
                    console.error(`Base64 decode error in Classic stamp: ${e.message}, image=${image.slice(0, 50)}...`);
                  }
                } else {
                  out += wl('Error', 'Invalid base64 format for Classic STAMP');
                  console.error(`Invalid base64 format: ${image.slice(0, 50)}...`);
                }
                return out;
              } else {
                out += wl('Error', `Invalid or insufficient multisig data for file size: file_size=${file_size}, hex length=${hex.length}, required=${file_size * 2 + 4}`);
                console.error(`Invalid file size: ${file_size}, hex=${hex}`);
                return out;
              }
            }
            let file = hex.slice(4, 4 + file_size * 2);
            console.log(`Extracted file data: file=${file}`);
            let hexPairs = file.match(/\w{2}/g);
            if (!hexPairs) {
              out += wl('Error', 'Invalid multisig data format for OLGA STAMP');
              console.error(`Invalid file data: ${file}`);
              return out;
            }
            let base64 = '';
            try {
              base64 = btoa(hexPairs.map(y => String.fromCharCode(parseInt(y, 16))).join(''));
              console.log(`Olga stamp base64: ${base64.slice(0, 50)}...`);
            } catch (e) {
              out += wl('Error', 'Failed to convert multisig data to base64: ' + e.message);
              console.error(`Base64 conversion error: ${e.message}, file=${file}`);
              return out;
            }
            if (!base64 || base64 === '') {
              out += wl('Error', 'Base64 data is undefined or empty for OLGA STAMP');
              console.error(`Base64 is undefined or empty: file=${file}`);
              return out;
            }
            let file_type = '';
            let isGzip = base64.startsWith('H4sI');
            let processedBase64 = base64;
            try {
              if (isGzip) {
                console.log('Detected gZIP-compressed Base64 in Olga stamp');
                let decoded;
                try {
                  decoded = atob(base64);
                  console.log(`Base64 decoded: ${decoded.slice(0, 50)}...`);
                } catch (e) {
                  out += wl('Error', 'Failed to decode base64 for OLGA STAMP: ' + e.message);
                  console.error(`Base64 decode error in Olga stamp: ${e.message}, base64=${base64.slice(0, 50)}...`);
                  return out;
                }
                try {
                  // Convert decoded string to Uint8Array for pako
                  let binary = new Uint8Array(decoded.length);
                  for (let i = 0; i < decoded.length; i++) {
                    binary[i] = decoded.charCodeAt(i);
                  }
                  let decompressed = pako.ungzip(binary, { to: 'string' });
                  processedBase64 = btoa(decompressed);
                  console.log(`Decompressed gZIP base64: ${processedBase64.slice(0, 50)}...`);
                } catch (e) {
                  out += wl('Error', 'Failed to decompress gZIP data for OLGA STAMP: ' + e.message);
                  console.error(`gZIP decompression error in Olga stamp: ${e.message}, base64=${base64.slice(0, 50)}...`);
                  return out;
                }
              }
              let decoded;
              try {
                decoded = atob(processedBase64);
                console.log(`Decoded Olga stamp starts with: ${decoded.slice(0, 50)}...`);
              } catch (e) {
                out += wl('Error', 'Invalid base64 data for OLGA STAMP: ' + e.message);
                console.error(`Base64 decode error in Olga stamp: ${e.message}, base64=${base64.slice(0, 50)}...`);
                return out;
              }
              if (processedBase64.slice(0, 6) === 'R0lGOD') {
                file_type = 'gif';
                console.log('Detected GIF in Olga stamp');
              } else if (processedImage.slice(0, 6) === 'iVBORw') {
                file_type = 'png';
                console.log('Detected PNG in Olga stamp');
              } else if (processedBase64.slice(0, 4) === '/9j/') {
                file_type = 'jpeg';
                console.log('Detected JPEG in Olga stamp');
              } else if (processedBase64.slice(0, 5) === 'PHN2Z' || processedBase64.slice(0, 5) === 'PD94b') {
                file_type = 'svg+xml';
                console.log('Detected SVG in Olga stamp');
              } else if (processedBase64.slice(0, 5) === 'UklGR') {
                file_type = 'webp';
                console.log('Detected WebP in Olga stamp');
              } else {
                file_type = 'html';
                console.log('Detected HTML in Olga stamp (default)');
              }

              out += wl('File size (bytes)', file_size);
              out += wl('Burned (sat)', dust);
              out += wl('Burned (btc)', (dust / 100000000).toFixed(8));
              out += wl('Asset', assetOrCPID);
              out += wl('Compression', isGzip ? 'gZIP' : 'None');
              out += wl('MIME Type', file_type === 'html' ? 'text/html' : `image/${file_type}`);

              let dimensions = await getImageDimensions(processedBase64, file_type);
              out += wl('Dimensions', dimensions);
              out += `<div class="output-row"><span class="output-label">Description</span><span class="output-value"><details><summary>Base64: (click to expand/collapse)</summary><pre class="base64-content">STAMP:${base64}</pre></details></span></div>`;
              out += `<div class="output-row"><span class="output-label">Description (hex)</span><span class="output-value"><details><summary>Hex: (click to expand/collapse)</summary><pre class="base64-content">${chunk(bin2hex('STAMP:' + base64), 96)}</pre></details></span></div>`;
              
              if (file_type === 'html') {
                out += `<iframe class="stamp-iframe" src="data:text/html;base64,${processedBase64}"></iframe><br>`;
              } else {
                out += `<img class="stamp-image" src="data:image/${file_type};base64,${processedBase64}" /><br>`;
              }
            } catch (e) {
              out += wl('Error', 'Invalid base64 data for OLGA STAMP: ' + e.message);
              console.error(`Base64 validation error: ${e.message}, base64=${base64.slice(0, 50)}...`);
            }
          } else {
            let hex = '';
            let dust = 0;
            for (let i = 0; i < p2wsh.length; i++) {
              hex += p2wsh[i][0].slice(4);
              dust += p2wsh[i][1];
            }
            let file_size_hex = hex.slice(0, 4);
            let file_size = parseInt(file_size_hex, 16);
            console.log(`P2WSH file size hex=${file_size_hex}, file_size=${file_size}, hex length=${hex.length}`);
            if (isNaN(file_size) || file_size <= 0 || hex.length < file_size * 2 + 4) {
              out += wl('Error', `Invalid or insufficient P2WSH data for file size: file_size=${file_size}, hex length=${hex.length}, required=${file_size * 2 + 4}`);
              console.error(`Invalid P2WSH file size: ${file_size}, hex=${hex}`);
              return out;
            }
            let file = hex.slice(4, 4 + file_size * 2);
            console.log(`P2WSH file data: file=${file}`);
            let hexPairs = file.match(/\w{2}/g);
            if (!hexPairs) {
              out += wl('Error', 'Invalid P2WSH data format for OLGA STAMP');
              console.error(`Invalid P2WSH file data: ${file}`);
              return out;
            }
            let base64 = '';
            try {
              base64 = btoa(hexPairs.map(y => String.fromCharCode(parseInt(y, 16))).join(''));
              console.log(`P2WSH base64: ${base64.slice(0, 50)}...`);
            } catch (e) {
              out += wl('Error', 'Failed to convert P2WSH data to base64: ' + e.message);
              console.error(`P2WSH base64 conversion error: ${e.message}, file=${file}`);
              return out;
            }
            if (!base64 || base64 === '') {
              out += wl('Error', 'Base64 data is undefined or empty for OLGA STAMP');
              console.error(`Base64 is undefined or empty: file=${file}`);
              return out;
            }
            let file_type = '';
            let isGzip = base64.startsWith('H4sI');
            let processedBase64 = base64;
            try {
              if (isGzip) {
                console.log('Detected gZIP-compressed Base64 in P2WSH');
                let decoded;
                try {
                  decoded = atob(base64);
                  console.log(`Base64 decoded: ${decoded.slice(0, 50)}...`);
                } catch (e) {
                  out += wl('Error', 'Failed to decode base64 for OLGA STAMP (P2WSH): ' + e.message);
                  console.error(`Base64 decode error in P2WSH: ${e.message}, base64=${base64.slice(0, 50)}...`);
                  return out;
                }
                try {
                  // Convert decoded string to Uint8Array for pako
                  let binary = new Uint8Array(decoded.length);
                  for (let i = 0; i < decoded.length; i++) {
                    binary[i] = decoded.charCodeAt(i);
                  }
                  let decompressed = pako.ungzip(binary, { to: 'string' });
                  processedBase64 = btoa(decompressed);
                  console.log(`Decompressed gZIP base64: ${processedBase64.slice(0, 50)}...`);
                } catch (e) {
                  out += wl('Error', 'Failed to decompress gZIP data for OLGA STAMP (P2WSH): ' + e.message);
                  console.error(`gZIP decompression error in P2WSH: ${e.message}, base64=${base64.slice(0, 50)}...`);
                  return out;
                }
              }
              let decoded;
              try {
                decoded = atob(processedBase64);
                console.log(`Decoded P2WSH starts with: ${decoded.slice(0, 50)}...`);
              } catch (e) {
                out += wl('Error', 'Invalid base64 data for OLGA STAMP (P2WSH): ' + e.message);
                console.error(`Base64 decode error in P2WSH: ${e.message}, base64=${base64.slice(0, 50)}...`);
                return out;
              }
              if (processedBase64.slice(0, 6) === 'R0lGOD') {
                file_type = 'gif';
                console.log('Detected GIF in P2WSH');
              } else if (processedBase64.slice(0, 6) === 'iVBORw') {
                file_type = 'png';
                console.log('Detected PNG in P2WSH');
              } else if (processedBase64.slice(0, 4) === '/9j/') {
                file_type = 'jpeg';
                console.log('Detected JPEG in P2WSH');
              } else if (processedBase64.slice(0, 5) === 'PHN2Z' || processedBase64.slice(0, 5) === 'PD94b') {
                file_type = 'svg+xml';
                console.log('Detected SVG in P2WSH');
              } else if (processedBase64.slice(0, 5) === 'UklGR') {
                file_type = 'webp';
                console.log('Detected WebP in P2WSH');
              } else {
                file_type = 'html';
                console.log('Detected HTML in P2WSH (default)');
              }

              out += wl('File size (byte)', file_size);
              out += wl('Burned (sat)', dust);
              out += wl('Burned (btc)', (dust / 100000000).toFixed(8));
              out += wl('Asset', assetOrCPID);
              out += wl('Compression', isGzip ? 'gZIP' : 'None');
              out += wl('MIME Type', file_type === 'html' ? 'text/html' : `image/${file_type}`);
              
              out += `<div class="output-row"><span class="output-label">Description</span><span class="output-value"><details><summary>Base64: (click to expand/collapse)</summary><pre class="base64-content">STAMP:${base64}</pre></details></span></div>`;
              out += `<div class="output-row"><span class="output-label">Description (hex)</span><span class="output-value"><details><summary>Hex: (click to expand/collapse)</summary><pre class="base64-content">${chunk(bin2hex('STAMP:' + base64), 96)}</pre></details></span></div>`;
              
              let dimensions = await getImageDimensions(processedBase64, file_type);
              out += wl('Dimensions', dimensions);
              if (file_type === 'html') {
                out += `<iframe class="stamp-iframe" src="data:text/html;base64,${processedBase64}"></iframe><br>`;
              } else {
                out += `<img class="stamp-image" src="data:image/${file_type};base64,${processedBase64}" /><br>`;
              }
            } catch (e) {
              out += wl('Error', 'Invalid base64 data for OLGA STAMP (P2WSH): ' + e.message);
              console.error(`Base64 validation error in P2WSH: ${e.message}, base64=${base64.slice(0, 50)}...`);
            }
          }
        }
      }
      return out;
    }

    window.onload = function() {
      if (tx) {
        document.getElementById('txid').value = tx;
        get_json(tx);
      }
    };
  </script>

  <style>
body {
    margin: 0;
    padding: 0;
    font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif;
}

#content {
    margin: auto;
    max-width: 800px;
    border: 2px solid #8B8B81;
    border-radius: 12px;
    padding: 20px;
    background-color: #BFBFBF;
    box-sizing: border-box;
    overflow-y: auto;
    scrollbar-width: none;
    -ms-overflow-style: none;
    max-height: 100vh;
}

#content::-webkit-scrollbar {
    display: none;
}

h1 {
    font-size: clamp(1.5rem, 5vw, 1.8rem);
    margin: 0 0 1rem;
    text-align: center;
}

p {
    font-size: clamp(0.9rem, 4vw, 1rem);
    margin: 0.5rem 0;
    line-height: 1.5;
}

#txid {
    width: 100%;
    padding: 0.75rem;
    font-size: 1rem;
    border: 1px solid #ccc;
    border-radius: 6px;
    box-sizing: border-box;
    margin-bottom: 0.5rem;
}

input[type=submit] {
    width: 100%;
    padding: 0.75rem;
    font-size: 1rem;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    transition: background-color 0.2s;
}

input[type=submit]:hover {
    background-color: #0056b3;
}

#output {
    font-size: clamp(1rem, 3.5vw, 1.2rem);
    margin: 1rem 1rem;
}

.output-row {
    display: flex;
    justify-content: space-between;
    margin-bottom: 0.2rem;
}

.output-label {
    flex: 0 0 25%;
    text-align: left;
}

.output-value {
    flex: 0 0 70%;
    text-align: left;
    word-break: break-word;
    overflow-wrap: break-word;
}

.section-title {
    font-weight: bold;
    margin: 1rem 0 1rem;
    font-size: clamp(1.2rem, 4vw, 1.2rem);
}

.stamp-image, .stamp-iframe {
    width: 250px;
    height: auto;
    border: 1px solid #000;
    margin: 1rem 0;
    display: block;
}

.stamp-image {
    image-rendering: pixelated;
}

.stamp-iframe {
    aspect-ratio: 1/1;
}

details {
    cursor: pointer;
    margin: 0.5rem 0;
}

summary {
    font-size: clamp(1rem, 3.5vw, 1.2rem);
}

pre {
    font-size: clamp(0.8rem, 3vw, 0.8rem);
    margin: 0.5rem 0;
    padding: 0.75rem;
    border: 1px solid #ddd;
    border-radius: 4px;
    white-space: pre-wrap;
    overflow-x: auto;
}

pre.base64-content {
    white-space: pre-wrap;
    word-wrap: break-word;
    overflow-wrap: break-word;
    max-width: 100%;
}

#output2 a {
    font-size: clamp(0.8rem, 30vw, 0.8rem);
    margin-right: 0.5rem;
}

#footer {
    font-size: clamp(0.8rem, 3.5vw, 0.9rem);
    text-align: center;
    margin-top: 5rem;
}

@media (max-width: 600px) {
    #output {
        font-size: clamp(0.8rem, 3vw, 0.8rem);
        margin: 0.5rem 0.5rem;
    }
  
    summary {
        font-size: clamp(0.8rem, 3vw, 0.8rem);
    }
    
    pre {
        font-size: clamp(0.6rem, 3vw, 0.6rem);
        margin: 0.5rem 0;
        padding: 0.75rem;
    }

    h1 {
        font-size: clamp(1.2rem, 4.5vw, 1.5rem);
    }
    
    p {
        font-size: clamp(0.8rem, 3.5vw, 0.8rem);
    }

    input[type=submit] {
        padding: 0.5rem;
    }

    .output-label {
        flex: 0 0 40%;
    }

    .output-value {
        flex: 0 0 65%;
    }
}
  </style>
</head>
<body>
<div id="content">
  <h1>Bitcoin STAMP Decoder v1.0</h1>
  <p>Enter a Bitcoin transaction ID to decode CP/Stamps Data.</p>
  <form onsubmit="event.preventDefault(); get_json(document.getElementById('txid').value);">
    <p>
      <input type="text" id="txid" name="txid" placeholder="Enter Bitcoin transaction ID" aria-label="Bitcoin transaction ID">
      <input type="submit" value="Submit">
    </p><br>
  </form>
  <p>This Stamp decoder is a remix of JP’s Counterparty Decoder—it raids the BlockCypher API, grabs transaction goodies, and pulls out STAMP data like a blockchain treasure hunter.</p> <br>
  <p><b>Note:</b> Now supports PNG, GIF, SVG+XML, WebP, and limited TEXT/HTML—Classic and Olga STAMPs included, no MIME left behind.</p>
  <pre>
 ____ ___ _____ ____ ___ ___ _   _        
| __ )_ _|_   _/ ___/ _ \_ _| \ | |      
|  _ \| |  | || |  | | | | ||  \| |      
| |_) | |  | || |__| |_| | || |\  |    
|____/___| |_| \____\___/___|_| \_|    
 
 ____ _____  _    __  __ ____  ____
/ ___|_   _|/ \  |  \/  |  _ \/ ___| 
\___ \ | | / _ \ | |\/| | |_) \___ \ 
 ___) || |/ ___ \| |  | |  __/ ___) |
|____/ |_/_/   \_\_|  |_|_|   |____/ 
  </pre>
  <div id="output"></div>
  <div id="output2"></div>
  <div id="footer">
    <p><i>Original Counterparty Decoder from JP<br>
    For more info, read <a href="https://jpjanssen.com/how-to-reverse-engineer-counterparty-txs/">blog post</a>.</i><br><br>
    Donate BTC, STAMP or SRC20 Tokens:<br>
      NSID Wallet (TBD)</p>
  </div>
</div>
</body>
</html>
